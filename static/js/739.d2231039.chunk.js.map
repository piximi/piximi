{"version":3,"file":"static/js/739.d2231039.chunk.js","mappings":"ucAoDaA,EAAAA,GAAUC,KAQPC,EAAAA,EAAaC,KAQXD,EAAAA,EAAaE,SAMbF,EAAAA,EAAaG,SAMbH,EAAAA,EAAaI,OAMbJ,EAAAA,EAAaK,K,6FCtFxB,IAAKP,EAAS,SAATA,GAAS,OAATA,EAAAA,EAAS,iBAATA,EAAAA,EAAS,qBAATA,EAAAA,EAAS,eAATA,CAAS,MA+BTE,EAAY,SAAZA,GAAY,OAAZA,EAAAA,EAAY,eAAZA,EAAAA,EAAY,uBAAZA,EAAAA,EAAY,uBAAZA,EAAAA,EAAY,mBAAZA,EAAAA,EAAY,iBAAZA,CAAY,K,0FCsPrBM,OAAOC,Q","sources":["utils/common/constants.ts","utils/common/enums.ts","utils/common/helpers.ts"],"sourcesContent":["import { AlertType, ImageSortKey } from \"./enums\";\nimport { AlertState, ImageSortKeyType } from \"./types\";\n\nexport const CATEGORY_COLORS = {\n  black: \"#000000\",\n  indianred: \"#C84C4C\",\n  red: \"#E60000\",\n  darkred: \"#8B0000\",\n  mediumvioletred: \"#C71585\",\n  palevioletred: \"#DB7093\",\n  sherpablue: \"#004949\",\n  darkcyan: \"#009292\",\n  indigo: \"#490092\",\n  navyblue: \"#006ddb\",\n  heliotrope: \"#b66dff\",\n  mayablue: \"#6db6ff\",\n  columbiablue: \"#b6dbff\",\n  olive: \"#924900\",\n  mangotango: \"#db6d00\",\n  green: \"#237700\",\n  citrus: \"#a89d00\",\n};\n\n//the default colors assigned to a loaded image\nexport const DEFAULT_COLORS: Array<[number, number, number]> = [\n  [1, 0, 0], // red\n  [0, 1, 0], // green\n  [0, 0, 1], // blue\n  [1, 1, 0], // yellow\n  [0, 1, 1], // cyan\n  [1, 0, 1], // magneta\n];\n\nexport const UNKNOWN_IMAGE_CATEGORY_COLOR = \"#AAAAAA\";\nexport const UNKNOWN_ANNOTATION_CATEGORY_COLOR = \"#920000\";\n\nexport const APPLICATION_COLORS = {\n  classifierList: \"#DCF3F450\",\n  segmenterList: \"#E9E5FA50\",\n  borderColor: \"#0000001f\",\n  highlightColor: \"#0000000a\",\n};\n\nexport const dimensions = {\n  leftDrawerWidth: 256,\n  toolDrawerWidth: 56,\n  annotatorToolOptionsWidth: 200,\n  stagePaddingX: 50,\n  stageInfoHeight: 21,\n};\n\nexport const defaultAlert: AlertState = {\n  alertType: AlertType.Info,\n  name: \"None\",\n  description: \"default state\",\n  visible: false,\n};\n\nexport const defaultImageSortKey: ImageSortKeyType = {\n  imageSortKeyName: \"None\",\n  imageSortKey: ImageSortKey.None,\n  comparerFunction: (a, b) => 0,\n  objectType: \"All\",\n};\n\nexport const availableImageSortKeys: ImageSortKeyType[] = [\n  {\n    imageSortKeyName: \"File name\",\n    imageSortKey: ImageSortKey.FileName,\n    comparerFunction: (a, b) => a.name.localeCompare(b.name),\n    objectType: \"Images\",\n  },\n  {\n    imageSortKeyName: \"Category\",\n    imageSortKey: ImageSortKey.Category,\n    comparerFunction: (a, b) => a.category.name.localeCompare(b.category.name),\n    objectType: \"All\",\n  },\n  {\n    imageSortKeyName: \"Random\",\n    imageSortKey: ImageSortKey.Random,\n    comparerFunction: (a, b) => (Math.round(Math.random() * 10) >= 5 ? 1 : -1),\n    objectType: \"All\",\n  },\n  {\n    imageSortKeyName: \"Image\",\n    imageSortKey: ImageSortKey.Image,\n    comparerFunction: (a, b) => a.name.localeCompare(b.name),\n    objectType: \"Annotations\",\n  },\n];\n\nexport const mobileBreakpoints = [\"xs\", \"sm\"];\n","export enum AlertType {\n  Error,\n  Warning,\n  Info,\n}\n\nexport enum HotkeyContext {\n  ProjectView,\n  AnnotatorView,\n  MeasurementsView,\n  ClassifierDialog,\n  SegmenterDialog,\n  ExampleProjectDialog,\n  ImportTensorflowModelDialog,\n  ConfirmationDialog,\n  AppSettingsDialog,\n}\n\nexport enum Languages {\n  Arabic = \"Arabic\",\n  English = \"English\",\n  Farsi = \"Farsi\",\n  Finnish = \"Finnish\",\n  French = \"French\",\n  German = \"German\",\n  Greek = \"Greek\",\n  Hindi = \"Hindi\",\n  Hungarian = \"Hungarian\",\n  Spanish = \"Spanish\",\n}\n\nexport enum ImageSortKey {\n  None,\n  FileName,\n  Category,\n  Random,\n  Image,\n}\n\nexport enum ThingSortKey {\n  None = \"None\",\n  FileName = \"File Name\",\n  Category = \"Category\",\n  Random = \"Random\",\n  Name = \"Name\",\n}\n","// ignore-no-logs\n\nimport { v4 as uuidv4 } from \"uuid\";\nimport StackTrace from \"stacktrace-js\";\nimport { BitDepth, DataArray } from \"utils/file-io/types\";\nimport * as ImageJS from \"image-js\";\nimport { tensor2d, image as tfImage } from \"@tensorflow/tfjs\";\nimport {\n  availableImageSortKeys,\n  defaultImageSortKey,\n  UNKNOWN_IMAGE_CATEGORY_COLOR,\n} from \"./constants\";\nimport { AlertType, ImageSortKey } from \"./enums\";\nimport { FilterType, ImageSortKeyType, RecursivePartial } from \"./types\";\nimport { Category, ImageObject, Shape, ShapeArray } from \"store/data/types\";\nimport { UNKNOWN_CATEGORY_NAME } from \"store/data/constants\";\nimport { SelectionTreeItems } from \"store/measurements/types\";\n\n/* \n  ERROR HANDLING / LOGGING\n*/\nexport const getStackTraceFromError = async (error: Error): Promise<string> => {\n  var stacktrace = error.stack ? error.stack : \"\";\n  try {\n    var stackFrames = await StackTrace.fromError(error);\n    stacktrace = stackFrames\n      .map((stackFrame) => stackFrame.toString())\n      .join(\"\\n\");\n  } catch (error) {\n    console.error(\"Could not resolve stacktrace\", error);\n  }\n\n  return stacktrace;\n};\n\nexport const createGitHubIssue = (\n  title: string,\n  body: string,\n  alertType: AlertType = AlertType.Error\n) => {\n  const label = alertType === AlertType.Error ? \"bug\" : \"help%20wanted\";\n  const url =\n    \"https://github.com/piximi/piximi/issues/new?title=\" +\n    encodeURIComponent(title) +\n    \"&labels=\" +\n    label +\n    \"&body=\" +\n    encodeURIComponent(body);\n  window.open(url);\n};\n\nexport const logger = (\n  message: any | any[],\n  options?: { level?: \"log\" | \"warn\" | \"error\"; dev?: boolean }\n) => {\n  if (!options) {\n    options = { level: \"log\" };\n  } else {\n    if (!options.level) {\n      options.level = \"log\";\n    }\n  }\n  if (Array.isArray(message)) {\n    message = message.join(\"\");\n  }\n  if (options?.dev) {\n    if (process.env.NODE_ENV !== \"production\") {\n      switch (options.level) {\n        case \"log\":\n          console.log(message);\n          break;\n        case \"warn\":\n          console.warn(message);\n          break;\n        case \"error\":\n          console.error(message);\n          break;\n        default:\n          break;\n      }\n    }\n  } else {\n    switch (options.level) {\n      case \"log\":\n        console.log(message);\n        break;\n      case \"warn\":\n        console.warn(message);\n        break;\n      case \"error\":\n        console.error(message);\n        break;\n      default:\n        break;\n    }\n  }\n};\n\n/* \n  ARRAY HELPERS\n*/\n\nexport const enumKeys = <O extends object, K extends keyof O = keyof O>(\n  obj: O\n): K[] => {\n  return Object.keys(obj).filter((k) => Number.isNaN(+k)) as K[];\n};\n\nexport const mutatingFilter = <T>(\n  array: Array<T>,\n  condition: (arg: T) => boolean\n): void => {\n  for (let l = array.length - 1; l >= 0; l -= 1) {\n    if (!condition(array[l])) array.splice(l, 1);\n  }\n};\n\nexport const toUnique = <T>(array: T[]): T[] => {\n  return [...new Set(array)];\n};\n\nexport const isFiltered = <T extends object>(\n  object: T,\n  filters: FilterType<T>\n): boolean => {\n  return Object.keys(object).some((key) => {\n    const itemValue = object[key as keyof T];\n    const filterValues = filters[key as keyof T];\n\n    if (Array.isArray(filterValues)) {\n      return (filterValues as Array<typeof itemValue>).includes(itemValue);\n    }\n\n    // If the key is not present in the record, include the item\n    return false;\n  });\n};\n\nexport const filterObjects = <T extends object>(\n  objectArr: T[],\n  filters: FilterType<T>\n): T[] => {\n  return objectArr.filter((item) => {\n    return Object.keys(item).every((key) => {\n      const itemValue = item[key as keyof T];\n      const filterValues = filters[key as keyof T];\n\n      if (Array.isArray(filterValues)) {\n        return !(filterValues as Array<typeof itemValue>).includes(itemValue);\n      }\n\n      // If the key is not present in the record, include the item\n      return true;\n    });\n  });\n};\n\nexport const recursiveAssign = <T extends object>(\n  existingObject: T,\n  updates: RecursivePartial<T>\n) => {\n  Object.entries(updates).forEach(([key, value]) => {\n    if (typeof existingObject[key as keyof T] === \"object\") {\n      recursiveAssign(\n        existingObject[key as keyof T] as object,\n        updates[key as keyof T]!\n      );\n    } else {\n      Object.assign(\n        existingObject[key as keyof T] as object,\n        updates[key as keyof T]!\n      );\n    }\n  });\n};\n\nexport const distinctFilter = <T>(value: T, index: number, self: T[]) => {\n  return self.indexOf(value) === index;\n};\n\nexport const getSubset = <T, K extends keyof T>(object: T, keys: K[]) => {\n  const subset: Record<string, (typeof object)[K]> = {};\n\n  keys.forEach((key) => {\n    subset[key as string] = object[key];\n  });\n  return subset;\n};\n\nexport const convertShapeToArray = (shape: Shape): ShapeArray => {\n  return Object.values(shape) as ShapeArray;\n};\n\nexport const convertArrayToShape = (array: ShapeArray): Shape => {\n  return {\n    planes: array[0],\n    height: array[1],\n    width: array[2],\n    channels: array[3],\n  };\n};\n\nexport const capitalize = (input: string) => {\n  const capitalized: string[] = [];\n\n  const words = input.split(\" \");\n\n  words.forEach((word) => {\n    capitalized.push(word.charAt(0).toUpperCase() + word.slice(1));\n  });\n  return capitalized.join(\" \");\n};\n\n/*\n  CATEGORY HELPERS\n*/\n\nexport const generateUUID = (options?: { definesUnknown: boolean }) => {\n  let id = uuidv4();\n  let unknownFlag: string;\n  if (options?.definesUnknown) {\n    unknownFlag = \"0\";\n  } else {\n    unknownFlag = \"1\";\n  }\n  return unknownFlag + id.slice(1);\n};\n\nexport const isUnknownCategory = (categoryId: string) => {\n  return categoryId[0] === \"0\";\n};\n\nexport const generateUnknownCategory = (kind: string) => {\n  const unknownCategoryId = generateUUID({ definesUnknown: true });\n  const unknownCategory: Category = {\n    id: unknownCategoryId,\n    name: UNKNOWN_CATEGORY_NAME,\n    color: UNKNOWN_IMAGE_CATEGORY_COLOR,\n    containing: [],\n    kind: kind,\n    visible: true,\n  };\n  return unknownCategory;\n};\n\n/*\n  FILE HELPERS\n*/\n\nexport class PseudoFileList {\n  private _files: File[];\n\n  constructor(files: File[]) {\n    let self = this;\n    this._files = files;\n\n    return new Proxy(this, {\n      get(target, prop) {\n        if (!isNaN(Number(prop)) && !(prop in target)) {\n          return self._files[Number(prop)];\n        } else {\n          return Reflect.get(target, prop);\n        }\n      },\n    }) satisfies FileList;\n  }\n\n  public item(elem: number) {\n    return this._files[elem];\n  }\n\n  public get length() {\n    return this._files.length;\n  }\n\n  [key: number]: File;\n\n  [Symbol.iterator](): IterableIterator<File> {\n    return this._files[Symbol.iterator]();\n  }\n}\n\n/*\n  STRING HELPERS\n*/\n\nexport const pluralize = (word: string, count: number) => {\n  return `${count > 1 ? word + \"s\" : word}`;\n};\n\n/*\n =======================\n General Utility Methods\n =======================\n */\n\n/*\n * Method to rename a cateogry/image if a category/image with this name already exists\n */\nexport const replaceDuplicateName = (\n  newName: string,\n  existingNames: Array<string>\n) => {\n  let currentName = newName;\n  let i = 1;\n  while (existingNames.includes(currentName)) {\n    currentName = newName + `_${i}`;\n    i += 1;\n  }\n  return currentName;\n};\n\n//HACK: new\nexport const newReplaceDuplicateName = (\n  newName: string,\n  existingNames: Array<string>\n) => {\n  let currentName = newName;\n  let count = 0;\n  // eslint-disable-next-line\n  const nameRe = new RegExp(`${newName}(_\\d+)?`, \"g\");\n  existingNames.forEach((name) => {\n    if (!!nameRe.exec(name)) {\n      const suffix = +name.split(\"_\")[1];\n      if (suffix > count) {\n        count = suffix;\n      }\n    }\n  });\n  return !count ? currentName : `${currentName}_${count + 1}`;\n};\n\nexport const scaleUpRange = (\n  range: [number, number],\n  bitDepth: BitDepth\n): [number, number] => {\n  return [\n    Math.floor(range[0] * (2 ** bitDepth - 1)),\n    Math.floor(range[1] * (2 ** bitDepth - 1)),\n  ];\n};\n\nexport const scaleUpRanges = (\n  ranges: { [channel: number]: [number, number] },\n  bitDepth: BitDepth,\n  opts: { inPlace: boolean } = { inPlace: false }\n): { [channel: number]: [number, number] } => {\n  let operandRanges = opts.inPlace ? ranges : { ...ranges };\n\n  for (const ch of Object.keys(ranges)) {\n    const chKey = parseInt(ch);\n    operandRanges[chKey] = scaleUpRange(ranges[chKey], bitDepth);\n  }\n\n  return ranges;\n};\n\nexport const scaleDownRange = (\n  range: [number, number],\n  bitDepth: BitDepth\n): [number, number] => {\n  return [range[0] / (2 ** bitDepth - 1), range[1] / (2 ** bitDepth - 1)];\n};\n\nexport const scaleDownRanges = (\n  ranges: { [channel: number]: [number, number] },\n  bitDepth: BitDepth,\n  opts: { inPlace: boolean } = { inPlace: false }\n): { [channel: number]: [number, number] } => {\n  let operandRanges = opts.inPlace ? ranges : { ...ranges };\n\n  for (const ch of Object.keys(ranges)) {\n    const chKey = parseInt(ch);\n    operandRanges[chKey] = scaleDownRange(ranges[chKey], bitDepth);\n  }\n\n  return ranges;\n};\n\nexport const extractMinMax = (ranges: {\n  [channel: number]: [number, number];\n}) => {\n  const channels = Object.keys(ranges).map((ch) => parseInt(ch));\n  const mins = Array(channels.length);\n  const maxs = Array(channels.length);\n\n  for (const ch of channels) {\n    const [min, max] = ranges[ch];\n    mins[ch] = min;\n    maxs[ch] = max;\n  }\n\n  return { mins, maxs };\n};\n\nexport const convertToDataArray = (\n  depth: number,\n  source: DataArray | Array<number>\n): DataArray => {\n  switch (depth) {\n    case 1:\n      throw Error(\"Binary bit depth not (yet) supported\");\n    case 8:\n      return Uint8Array.from(source);\n    case 16:\n      return Uint16Array.from(source);\n    case 32:\n      return Float32Array.from(source);\n    default:\n      throw Error(\"Unrecognized bit depth\");\n  }\n};\n\nexport const getPropertiesFromImage = async (\n  image: ImageObject,\n  annotation: { boundingBox: number[] }\n) => {\n  const renderedIm = await ImageJS.Image.load(image.src);\n  const normalizingWidth = image.shape.width - 1;\n  const normalizingHeight = image.shape.height - 1;\n  const bbox = annotation.boundingBox;\n  const x1 = bbox[0] / normalizingWidth;\n  const x2 = bbox[2] / normalizingWidth;\n  const y1 = bbox[1] / normalizingHeight;\n  const y2 = bbox[3] / normalizingHeight;\n  const box = tensor2d([[y1, x1, y2, x2]]);\n  const width = bbox[2] - bbox[0];\n  const height = bbox[3] - bbox[1];\n  const objectImage = renderedIm.crop({\n    x: Math.abs(bbox[0]),\n    y: Math.abs(bbox[1]),\n    width: Math.abs(Math.min(image.shape.width, bbox[2]) - bbox[0]),\n    height: Math.abs(Math.min(image.shape.height, bbox[3]) - bbox[1]),\n  });\n  const objSrc = objectImage.getCanvas().toDataURL();\n  const data = tfImage.cropAndResize(image.data, box, [0], [height, width]);\n\n  return {\n    data: data,\n    src: objSrc,\n    imageId: image.id,\n    boundingBox: bbox,\n  };\n};\n\nexport const getPropertiesFromImageSync = (\n  renderedIm: ImageJS.Image,\n  image: ImageObject,\n  annotation: { boundingBox: number[] }\n) => {\n  const normalizingWidth = image.shape.width - 1;\n  const normalizingHeight = image.shape.height - 1;\n  const bbox = annotation.boundingBox;\n  const x1 = bbox[0] / normalizingWidth;\n  const x2 = bbox[2] / normalizingWidth;\n  const y1 = bbox[1] / normalizingHeight;\n  const y2 = bbox[3] / normalizingHeight;\n  const box = tensor2d([[y1, x1, y2, x2]]);\n  const width = bbox[2] - bbox[0];\n  const height = bbox[3] - bbox[1];\n  const objectImage = renderedIm.crop({\n    x: Math.abs(bbox[0]),\n    y: Math.abs(bbox[1]),\n    width: Math.abs(Math.min(image.shape.width, bbox[2]) - bbox[0]),\n    height: Math.abs(Math.min(image.shape.height, bbox[3]) - bbox[1]),\n  });\n  const objSrc = objectImage.getCanvas().toDataURL();\n  const data = tfImage.cropAndResize(image.data, box, [0], [height, width]);\n  box.dispose();\n\n  return {\n    data: data,\n    src: objSrc,\n    imageId: image.id,\n    boundingBox: bbox as [number, number, number, number],\n    bitDepth: image.bitDepth,\n  };\n};\nconst componentToHex = (c: number) => {\n  var hex = (c * 255).toString(16);\n  return hex.length === 1 ? \"0\" + hex : hex;\n};\n\nexport const rgbToHex = (rgb: [number, number, number]) => {\n  return (\n    \"#\" +\n    componentToHex(rgb[0]) +\n    componentToHex(rgb[1]) +\n    componentToHex(rgb[2])\n  );\n};\n\nexport const sortTypeByKey = (key: ImageSortKey): ImageSortKeyType => {\n  const sortKeyIdx = availableImageSortKeys\n    .map((e) => e.imageSortKey)\n    .indexOf(key);\n\n  if (sortKeyIdx >= 0) {\n    return availableImageSortKeys[sortKeyIdx];\n  } else {\n    return defaultImageSortKey;\n  }\n};\n\nexport const updateRecord = <T extends string | number | symbol, K>(\n  record: Record<T, K[]>,\n  key: T,\n  value: K\n) => {\n  if (key in record) {\n    record[key].push(value);\n  } else {\n    record[key] = [value];\n  }\n};\n\n/*\n  Given a selection tree item, updates the selection status of all of its children\n*/\nexport const selectTreeItemChildren = (\n  updates: RecursivePartial<SelectionTreeItems>,\n  itemId: string,\n  items: SelectionTreeItems,\n  selectionStatus: \"on\" | \"off\"\n) => {\n  const dataItem = items[itemId];\n  if (dataItem) {\n    // data item exists\n    if (dataItem.children) {\n      // data item has children, select or deselect all children\n      dataItem.children.forEach((child) => {\n        selectTreeItemChildren(updates, child, items, selectionStatus);\n      });\n    } else {\n      updates[dataItem.id as keyof SelectionTreeItems] = {\n        state: selectionStatus,\n      };\n    }\n  }\n};\n\nexport const isObjectEmpty = <T extends Object>(obj: T) => {\n  return Object.keys(obj).length === 0;\n};\n"],"names":["AlertType","Info","ImageSortKey","None","FileName","Category","Random","Image","Symbol","iterator"],"sourceRoot":""}